"""
🔐 Push Notification 인증 및 검증 모듈

이 모듈은 JWT 기반의 푸시 알림 인증 시스템을 구현합니다.  
발신자(Sender)는 푸시 알림 전송 시 JWT 토큰을 생성하여 서명하고,  
수신자(Receiver)는 해당 JWT의 서명과 메시지 본문 무결성을 검증합니다.  
공개 키는 JWK 형식으로 제공되며, JWKS 엔드포인트를 통해 외부에 노출됩니다.

📦 주요 클래스 및 기능 설명

1. PushNotificationAuth (부모 클래스)
   - `_calculate_request_body_sha256(data)`: 
     요청 본문(dict)의 내용을 안정된 JSON 직렬화 방식으로 SHA256 해시 처리.
     이는 서명과 검증 양쪽에서 동일한 방식으로 사용되어야 함.

2. PushNotificationSenderAuth (푸시 알림 발신자)
   - `generate_jwk()`:
     RSA 공개/개인 키 쌍을 생성하고, 공개 키를 `public_keys` 리스트에 저장. 개인 키는 JWT 서명용으로 보관.
   - `handle_jwks_endpoint(request)`:
     클라이언트가 공개키를 받아갈 수 있도록 JWKS(JSON Web Key Set) 응답을 반환.
   - `_generate_jwt(data)`:
     요청 본문 해시와 발급 시간(iat)을 포함한 JWT를 생성하고 개인키로 RS256 서명.
   - `send_push_notification(url, data)`:
     JWT를 Authorization 헤더에 담아 대상 URL로 JSON POST 요청을 전송.
   - `verify_push_notification_url(url)`:
     대상 URL이 유효한지 확인하기 위해 임의의 validationToken을 보내고 응답이 일치하는지 확인.

3. PushNotificationReceiverAuth (푸시 알림 수신자)
   - `load_jwks(jwks_url)`:
     JWKS(공개 키 모음) URL을 로드하여 JWT 서명을 검증할 준비를 함.
   - `verify_push_notification(request)`:
     - Authorization 헤더에서 JWT 추출
     - JWT 서명을 JWKS 공개 키로 검증
     - JWT 내부의 SHA256 해시와 실제 요청 본문을 비교하여 위변조 여부 확인
     - iat를 기준으로 5분 이내 요청인지 검사 (리플레이 공격 방지)

이 모듈은 푸시 알림 기반의 비동기 이벤트 통신에서 신뢰성과 보안을 강화하기 위한 용도로 설계되었습니다.
"""

from jwcrypto import jwk
import uuid
from starlette.responses import JSONResponse
from starlette.requests import Request
from typing import Any

import jwt
import time
import json
import hashlib
import httpx
import logging

from jwt import PyJWK, PyJWKClient

logger = logging.getLogger(__name__)
AUTH_HEADER_PREFIX = 'Bearer '

class PushNotificationAuth:
    def _calculate_request_body_sha256(self, data: dict[str, Any]):
        """Calculates the SHA256 hash of a request body.

        This logic needs to be same for both the agent who signs the payload and the client verifier.
        """
        body_str = json.dumps(
            data,
            ensure_ascii=False,
            allow_nan=False,
            indent=None,
            separators=(",", ":"),
        )
        return hashlib.sha256(body_str.encode()).hexdigest()

class PushNotificationSenderAuth(PushNotificationAuth):
    def __init__(self):
        self.public_keys = []
        self.private_key_jwk: PyJWK = None

    @staticmethod
    async def verify_push_notification_url(url: str) -> bool:
        async with httpx.AsyncClient(timeout=10) as client:
            try:
                validation_token = str(uuid.uuid4())
                response = await client.get(
                    url,
                    params={"validationToken": validation_token}
                )
                response.raise_for_status()
                is_verified = response.text == validation_token

                logger.info(f"Verified push-notification URL: {url} => {is_verified}")            
                return is_verified                
            except Exception as e:
                logger.warning(f"Error during sending push-notification for URL {url}: {e}")

        return False

    def generate_jwk(self):
        key = jwk.JWK.generate(kty='RSA', size=2048, kid=str(uuid.uuid4()), use="sig")
        self.public_keys.append(key.export_public(as_dict=True))
        self.private_key_jwk = PyJWK.from_json(key.export_private())
    
    def handle_jwks_endpoint(self, _request: Request):
        """Allow clients to fetch public keys.
        """
        return JSONResponse({
            "keys": self.public_keys
        })
    
    def _generate_jwt(self, data: dict[str, Any]):
        """JWT is generated by signing both the request payload SHA digest and time of token generation.

        Payload is signed with private key and it ensures the integrity of payload for client.
        Including iat prevents from replay attack.
        """
        
        iat = int(time.time())

        return jwt.encode(
            {"iat": iat, "request_body_sha256": self._calculate_request_body_sha256(data)},
            key=self.private_key_jwk,
            headers={"kid": self.private_key_jwk.key_id},
            algorithm="RS256"
        )

    async def send_push_notification(self, url: str, data: dict[str, Any]):
        jwt_token = self._generate_jwt(data)
        headers = {'Authorization': f"Bearer {jwt_token}"}
        async with httpx.AsyncClient(timeout=10) as client: 
            try:
                response = await client.post(
                    url,
                    json=data,
                    headers=headers
                )
                response.raise_for_status()
                logger.info(f"Push-notification sent for URL: {url}")                            
            except Exception as e:
                logger.warning(f"Error during sending push-notification for URL {url}: {e}")

class PushNotificationReceiverAuth(PushNotificationAuth):
    def __init__(self):
        self.public_keys_jwks = []
        self.jwks_client = None

    async def load_jwks(self, jwks_url: str):
        self.jwks_client = PyJWKClient(jwks_url)
    
    async def verify_push_notification(self, request: Request) -> bool:
        auth_header = request.headers.get("Authorization")
        if not auth_header or not auth_header.startswith(AUTH_HEADER_PREFIX):
            print("Invalid authorization header")
            return False
        
        token = auth_header[len(AUTH_HEADER_PREFIX):]
        signing_key = self.jwks_client.get_signing_key_from_jwt(token)

        decode_token = jwt.decode(
            token,
            signing_key,
            options={"require": ["iat", "request_body_sha256"]},
            algorithms=["RS256"],
        )

        actual_body_sha256 = self._calculate_request_body_sha256(await request.json())
        if actual_body_sha256 != decode_token["request_body_sha256"]:
            # Payload signature does not match the digest in signed token.
            raise ValueError("Invalid request body")
        
        if time.time() - decode_token["iat"] > 60 * 5:
            # Do not allow push-notifications older than 5 minutes.
            # This is to prevent replay attack.
            raise ValueError("Token is expired")
        
        return True